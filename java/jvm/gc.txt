1.当系统出现内存溢出内存泄露,当gc成为系统达到更高并发量的瓶颈时,我们需要对gc有一定的了解
	本地方法区,jvm栈,计数器是线程私有,一般不用考虑gc
	方法区和heap区是重点考虑对象

2.判断对象是否死亡算法:
	1.引用计数法(pathy):给每个对象一个计数器,增加一个引用就+1,当一个引用失效时就-1.当计数器为0时,就可以吧对象干掉了,
		但是很难解决循环引用的问题.
		Aobject a = new Aobject();
		Bobject b = new Bobject();
		a.instanc = b.instanc;
		b.instanc = a.instanc;
		这个问题没发解决
	2.根搜索算法.(java)
		从所有可能成为gc root的对象开始向下搜索,搜索所经过的路径被称为引用链,当一个对象到达gc root没有任何引用链时,则证明此对象不可用.
		可作为gc root的对象有
		1.jvm栈中的对象,
		2.方法区中的静态变量.
		3.方法区中的常量.
		4.本地方法栈jni中的引用对象

3.垃圾回收算法.
	1.标记-清除算法.
		首先标记所有的需要回收的对象,标记完成之后统一回收,所有标记的对象.
		缺点:1.标记和回收的效率不高.
			2.容易造成大量的不连续的空间.
	2.复制算法.
		把内存分为大小相等的两块,每次只用一块,当需要回收的时候,把可用的对象复制到另一块,然后把之前一块全部清空.
			这样复制的效率高,而且不用担心碎片问题