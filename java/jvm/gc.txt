1.当系统出现内存溢出内存泄露,当gc成为系统达到更高并发量的瓶颈时,我们需要对gc有一定的了解
	本地方法区,jvm栈,计数器是线程私有,一般不用考虑gc
	方法区和heap区是重点考虑对象

2.判断对象是否死亡算法:
	1.引用计数法(pathy):给每个对象一个计数器,增加一个引用就+1,当一个引用失效时就-1.当计数器为0时,就可以吧对象干掉了,
		但是很难解决循环引用的问题.
		Aobject a = new Aobject();
		Bobject b = new Bobject();
		a.instanc = b.instanc;
		b.instanc = a.instanc;
		这个问题没发解决
	2.根搜索算法.(java)
		从所有可能成为gc root的对象开始向下搜索,搜索所经过的路径被称为引用链,当一个对象到达gc root没有任何引用链时,则证明此对象不可用.
		可作为gc root的对象有
		1.jvm栈中的对象,
		2.方法区中的静态变量.
		3.方法区中的常量.
		4.本地方法栈jni中的引用对象

3.垃圾回收算法.
	1.标记-清除算法.
		首先标记所有的需要回收的对象,标记完成之后统一回收,所有标记的对象.
		缺点:1.标记和回收的效率不高.
			2.容易造成大量的不连续的空间.
	2.复制算法.
		把内存分为大小相等的两块,每次只用一块,当需要回收的时候,把可用的对象复制到另一块,然后把之前一块全部清空.
			这样复制的效率高,而且不用担心碎片问题
	3.标记整理算法.
		标记复制算法在对象成活率高的时候回复制较多的对象,效率会降低,
		标记整理算法前面和标记清除算法一样,只是在回收所有标记对象之后不是复制,而是让说有对象往一边移动,然后清理掉端边界意外的内存
	4.分代收集算法.
		根据对象生命周期的不同而把java堆分为新生代和老生代.在新生代由于对象存活率较低,复制成本也就较低,可以采用复制算法,
		对于老生代,对象存活率较高,可以采用标记清除算法或则标记哦整理算法.
4.垃圾收集器
	1.Serial收集器
		Serial收集器是最基本的,历史最悠久的收集器.这是一个单线程的收集器,在他运行的时候所有的线程都必须停止(stop the world).
		有点:简单高效.
	2.ParNew收集器
		是Serial收集器的多线程版本
	3.Parallel Scavenge收集器
		是一个新生代搜集器,使用的是标记复制算法,并且是并行的多线程收集器
		Parallel Scavenge的目的在于达到一个可控制的吞吐量.
	4.Serial Old 收集器
		Serial Old是serial的老年代版本,采用的是标记整理算法.
	5.Parallel old收集器
		parallel Scavenge的老年代版本使用多线程的标记整理算法
	6.cms收集器(并发收集,低停顿)
		这是一个一获取最短回收时间为目标的收集器.可以获取最短的相应时间.采用的是标记清除算法实现的.主要分为四步:
			1.初始标记
				需要stop the word.仅仅只是标记一下gc root能直接关联到的对象,所以速度很快
			2.并发标记
				
			3.重新标记
				需要stop the word.主要是为了修正因为在并发标记期间因程序运行而导致标记变动的那一部分对象
			4.并发回收
		缺点:
			1.cms对cpu十分敏感.
			2.无法收集浮动垃圾.若cms在运行期间预留的内存不够用户程序继续运行,则促发一次concurrent mode failure.启用临时预案serial old 进行整理
			3.由于采用的是标记清除算法,会产生大量的碎片.容易造成full gc.这样会影响效率.
	7.G1收集器
		采用标记整理算法(不用担心碎片),可以精确的控制子啊m时间内垃圾回收的时间不超过n.
		
5.内存分配和回收策略.
	主要解决给对象分配内存和回收分配给对象内存的问题
	1.
