
概述:1.加载(loading)--->验证(verification)--->准备(preparation)--->解析(resolution)--->初始化(initialization)--->使用(using)--->卸载(unloading)

1.初始化时机:
	1.new关键字,使用读取设置static字段(编译时已经存在的除外,final修饰的除外),调用一个static方法的时候
	2.使用java.lang.reflect包的方法对类进行反射的时候,若类没有初始化,则需要初始化.
	3.当初始化一个类的时候若其父类没有初始化则对其父类初始化.
	4.当jvm启动的时候,包含main的类
	不会初始化的时机:
		1.对于静态字段调用之后只有定义它的类会初始化,继承它的自雷不会初始化,即使是用子类的名义调用的.
		2.通过数组来引用一个类的时候,这个类不会被初始化;Class[] it = new Class[10];
			因为jvm会自动生成一个L+类全名的新的类,这个类是一个一位数组元素类型为原来的类,
		3.引用一个类的静态常量,因为在编译期就已经确定了,生成.class之后两个类就没有关系了,所以不会初始化这个类.
		4.一个类在初始化的时候要求其父类必须初始化完成了,但是接口初始化的时候并不要求其父接口也初始化完成了,可以等到用到的时候在初始化
2.解析(Symbolic Reference)(direct reference)
	解析是讲jvm中的符号引用替换成直接引用的过程.
	解析动作主要针对的是类或接口,字段,类方法,接口方法四种.
	1.类或接口.
		1.若被解析的不是数组,那么jvm会把全限定名传给classloader进行加载,
		2.若是数组,那么会加载它的元素类型,然后jvm会创建一个有唯独和元素的数组.
		3.上面没有异常的时候进行验证,若没有访问权限会抛出IllegalAccessError.
	2.字段解析.
		要解析一个字段的符号引用首先要对该字段表内地class_index项中索引Constant_class_info符号进行解析,也就是该字段所属的类或者接口.若有任何异常都回到紫字段
		解析失败,若这个字段所属地类或则接口用C表示.jvm会在C中查找有没有匹配的项,若没有会在父类或则接口中递归查找.
		若查找成功则进行权限验证,若没有权限则抛出IllegalAccessError.
	3.类方法解析.
		通字段解析.
	4.接口方法解析.
		同字段解析.
3.初始化
	1.<clinit>()方法是有编译器自动收集类中的所有类变量和静态代码块实现的一个方法,顺序是类中定义的顺序.静态代码块只能访问到在他之前定义的
	变量 ,在它之后定义的只能赋值不能访问.
	2.<clinit>()与构造器不同,他不需要显示的调用父类的构造器,jvm会保证在子类的<clinit>()执行之前父类的<clinit>()方法已经执行完毕.
	3.由于父类的<clinit>()方法先执行也就是说,父类的静态代码块先执行.
	4.<clinit>()对类或则接口来说并不是必须的,若类或接口中没有静态代码块或则复制操作,可以没有<clinit>()方法.
	5.接口虽然没有静态代码块,但是有复制操作,所以也会有<clinit>()方法,只是在执行的时候不要求必须限制性父接口的该方法,类实现接口的时候也不要求先执行接口的该方法
	只有在用到父接口字段的时候才会执行.
	6.jvm会保证在多线程环境下,<clinit>()方法只会执行一次