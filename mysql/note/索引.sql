索引 index.
索引是在存储引擎层实现的,所以不同的存储引擎的索引的工作方式不一样,并不是所有的引擎都支持所有类型的索引.
即使是相同的索引,在不同的搜索引擎上的实现也可能不一样.

where子句的值是索引的子集.

一.B-TREE索引.
B-TREE索引使用B-TREE数据结构来存储数据.


索引对多个值进行排序的依据是create table中定义索引的顺序.

B-TREE索引的使用范围.
1.全值匹配.全值匹配指的是和索引中所有的列进行匹配.
2.匹配最左前列.即只使用索引的第一列.
3.匹配列前缀.也可以之匹配某一列的值的开头部分.
4.匹配范围值.可以查找某一范围内的值.
5.精确匹配某一列并范围匹配另一列.
6.只访问索引的查询.

B-TREE索引的限制
1.若不是按照索引的最左列开始查找,则无法使用索引.
2.不能跳过索引的列.
3.若查询中某个列的范围查询,则其右边的所有的列都无法使用索引优化.


二.哈希索引 (hash index)
哈希索引基于哈希表实现.只有精确匹配索引所有的列的查询才有效.
对于每一行索引,存储引擎都会对所有的索引咧计算一个哈戏码m,哈希吗是一个较小的值.并且不同的键值行计算出来的也不一样.
哈希索引将所有的哈希码存储在索引中.同时在哈希表中保存指向每个数据行的指针.


缺点:
1.哈希索引只包含哈希值和指针,而存储字段,所以不能用索引中的值来避免读取行,不过访问内存中的行速度很快,所以对性能影响不大.
2,哈希索引数据并不是按照索引值顺序排序的,所以无法用语排序.
3,哈希索引列也不支持部分索引咧匹配查找.因为哈//希索引始终是按照所有的索引咧来计算哈希值.
4,哈希索引只支持等值比较,不支持任何范围查询.
5.如果没有很多哈希冲突,哈希索引非常的快.
6.如果哈希冲突很多,那么一些索引的维护操作的代价会很高.

以上限制使哈希索引只能在很小的范围内使用,但是一旦使用,性能提升很显著.



mysql  innodb中若要索引的列字符串很大,则可以自己构建一个伪哈希索引.但需要多家一列






索引的优点.

1.索引将大大减少服务器需要烧苗的数据量.
2.索引可以帮助服务器避免排序和临时表.
3.索引可以将随机I/o变成顺序i/o;




高性能的索引策略.
索引的评分策略
一星索引.索引将相关的记录放到一起为一星索引.
二星索引.若索引中的数据顺序和查找中的排列顺序一致则获得二星.
三星索引.若索引中的列包含了查询中所有的列则是三星索引,

1.若列不是独立的,则mysql不能使用已有索引.独立的列是指列不能是表达式的一部分,也不能是函数的参数.
  select * from user where userId+1 = 5;//这个不是独立的列,不能使用索引.
  select * from user where to_days(current_date)-to_days(date_col)
  应该始终把索引咧放到比较符号的一侧.这样才能使用索引.
2.当要索引很长的列的时候可以使用模拟哈希索引.(一般不要使用sha1()和md5()这是强加密函数,使用crc32()若数据量很大则会出现很多冲突,可以考虑自己实现一个简单的函数)
	也可以只索引开始的部分字符(更常用).这样可以大大节约索引空间.从而提高索引效率.但这样也会降低索引的选择性(索引的不重复值/索引总条数).
	索引的选择性越高,查询效率越高.当为1时最好.性能最好.
    选择前缀索引的方式.方式一.先找出本列的重复数最高的几行,然后把列从左侧截取,在找出从夫数最高的几行,知道两者差不多.
	方式二,通过索引选择性找出.
	
	创建前缀索引.
	alter table user_demo add index indexName(city(7))
	计算多少个前缀合适的方法,
	先select count(columnName) as coun from tableName group by columnName order by coun limit 10;
	然后再一点一点的加
	select count(*) as cont,left(columnName(n)) as pref from tableName group by pref order by cont limit 10;
	当前几个重复的值差不多相等的时候就可以了.
	
3.多列索引.
   关于多列索引一个常见的错误就是为每个列创建独立的索引,或者按照错误的顺序创建了多列索引.
   
4.选择合适的索引顺序,(使用于btree索引)
	索引列的顺序是最容易引起困惑的地方,
	正确的索引顺序依赖于索引的查询,并且需要考虑如何更好的满足排序和分组的需要.
	在一个多列的btree索引中,索引列的顺序意味着索引按照最左列进行排序,其次是第二列等等,
	对于如何选择索引的顺序有一个经验法则:将选择性最高的列放到最前列.虽然这个法则可能远远没有你想象的重要.当不需要排序和分组时这个是很有用的.
	然而性能不止依赖于所有列的选择性(整体基数),也和查询条件的具体值有关.也就是和值的分布有关,可能需要根据那些查询频率较高的查询来调整索引列的顺序,让这种情况下缩影的选择性最高.
	不要忘记where语句中排序,分组和范围条件等其他因素.
	
聚簇索引:聚簇索引是一种数据存储方式.实际上是在同一个数据结构中保存了btree和数据行.
			innodb通过主键聚簇索引数据.如果没有主键则选择一个唯一的非空索引代替.若果没有这样的索引则会隐私的定义个逐渐作为聚簇索引.
			
			
		1.聚簇索引表最大限度的提高了io密集型应用 的性能.
		2限制:
			1.插入速度严重依赖于插入顺序.按照主键的顺序插入式最快的方式,否则会出现也分裂.严重影响性能.因此对于innodb我们会定义一个自增的id;
			2.更新主键的代价很高,因为将会导致被更新的行移动.因此对于innodb表我们一般定义为id不可更新.
			3.二级索引(表上的非聚簇索引.)访问需要两次索引查找.第一次找到主键,第二次根据主键找到对应的行数据.
			二级索引存储的是主键值,而不是指针.这是为了减少当行移动或页分裂时二级索引的维护工作.但会让二级索引占用更过的空间.	
			
覆盖索引:如果一个索引包含所有的要查询字段的值,我们就称之为覆盖索引.(覆盖索引能极大的提高性能.mysql只能用btree索引作为覆盖索引.)
		优点:
			1.索引条目通常远小于数据行大小,所以如果需要读取索引,mysql就会极大的减少访问量.
			2.以为索引是按顺序排列的,所以对于io密集型的范围查找会比随机从磁盘读取每一行数据的io要少很多.
			3.innodb的聚簇索引,的二次索引若为覆盖索引可以避免二次查询.
			
			
			
冗余和重复索引.
		最常见的冗余重复索引.主键,上面加上唯一限制,在建立一个主键索引.其实主键和唯一限制都是通过索引实现的这里就出现了三个一样的索引.
		冗余索引和重复索引的区别.
				冗余索引:创建了索引(a,b)又创建了索引(a)就是冗余索引.但是索引(b)不是冗余索引.其他类型的索引也都不是冗余索引;
		应该尽量的扩展现有索引,而不是增加新的索引.
		新增加索引会导致insert update delete越来越慢.
				
   
